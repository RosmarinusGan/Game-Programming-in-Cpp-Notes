1. A **game loop** is a loop that controls the overall flow for the entire game program.
2. Each iteration of a game loop is a **frame**. **frames per second(FPS)/frame rate**.
3. Anatomy of a Frame
   1. It processes any inputs. (input devices, networking data, replay data...)
   2. It updates the game world. 
   3. It generates any outputs. (graphics, audio, force feedback controllers...)
4. **Raster Graphics** means the display has a two-dimensional grid of picture elements (or **pixels**). These pixels can individually display a different amounts of light as well as different colors. The intensity and color of these pixels combine to create a perception of a continuous image for the viewer.
5. The **resolution** of a raster display refers to the width and height of the pixel grid.
6. Color displays mix colors additively to create a specific hue for each pixel. A common approach is to mix three colors together: red, green, and blue (abbreviated **RGB**). Different intensities of these RGB colors combine to create a range (or **gamut**) of colors.
7. Many games internally use a different color representation for much of their graphics computations like supporting transparency with an **alpha** value. The abbreviation **RGBA** references RGB colors with an additional alpha component.
8. The **Color Buffer** is a location in memory containing the color information for the entire screen. The display can use the color buffer for drawing the contents screen.
9. The memory usage of the color buffer depends on the number of bits that represent each pixel, called the **Color Depth**.(in the common 24-bit color depth, red, green, and blue each use 8 bits)
10. Given an 8-bit value for a color, there are two ways to reference this value in code. One approach involves simply using an unsigned integer corresponding to the number of bits for each color (or **channel**). The alternative approach is to normalize the integer over a decimal range from 0.0 to 1.0.
11. The **refresh rate**, or the frequency at which the display updates, may be different from the game's frame rate. And no current display technology can instantaneously update the entire screen at once. Whatever update pattern the display uses, it takes some fraction of a second for the whole screen to update.
12. Suppose a game writes to the color buffer, and the display reads from that same color buffer. Because the timing of the game's frame rate may not directly match the monitor's refresh rate, it's very like that the display will read from the color buffer while the game is writing to the buffer. It will cause problem, known as **Screen Tearing**.
13. Eliminating screen tearing requires two changes. The first idea of eliminating screen tearing is that with two separate buffers, the game can write to one (the **back buffer**) and, at the same time, the display can read from the other one (the **front buffer**). After the frame completes, the game and display swap their buffers. Due to the use of two colors buffers, the name for this technique is **double buffering**.
14. However, double buffering by itself does not eliminate screen tearing. Screen tearing still occurs if the display is drawing buffer X when the game wants to start writing to X. This usually happens only if the game is updating too quickly. The solution to this problem is to wait until the display finishes drawing its buffer before swapping. Developers call this approach **vertical synchronization**, or **vsync**, named after the signal that monitors send when they are about to refresh the screen. With vertical synchronization, the game might have to occasionally wait for a fraction of a second for the display to be ready. This causes unacceptable stuttering of the frame rate. Thus, a good idea is to offer vsync as an option in the engine so that you can choose between occasional screen tearing or occasional stuttering.
15. This dilemma may be solved with an **adaptive refresh rate** that varies based on the game. With this approach, rather than the display notifying the game when it refreshes, the game tells the display when to refresh.
16. The term **renderer** generically refers to any system that draws graphics, whether 2D or 3D.
17. It is important to distinguish **real time**, the time elapsing in the real world, from **game time**, the time elapsing in the game's world. "Update game" phase of the game loop should account for elapsed game time.
18. **Delta Time**, the amount of elapsed game time since the last frame. There is a **frame limiting** which forces the game loop to wait until a target delta time has elapsed. Also, you must watch out for a delta time that's too high. You can clamp the delta time to a maximum value.